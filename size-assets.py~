import os
import tkinter as tk
from tkinter import filedialog, messagebox
from PIL import Image
import numpy as np  # === NOVO: para composição rápida

APP_TITLE = "Gerador de Chunks 2D (12 combinações com 'prainha')"
REQ_SIZE = (1024, 1024)
OUT_SMALL = (100, 100)  # resolução opcional de saída
CORNER_RADIUS = 80

# === NOVO: parâmetros da prainha/ondulação
SHORE_W = 26      # largura (px) da faixa de "areia"
WAVE_AMP = 24       # amplitude da ondulação (px)
WAVE_PERIODS = 6    # nº de ondas ao longo da altura/largura

# -------------------------------------------------
# Utilidades
# -------------------------------------------------
def load_image(path):
    img = Image.open(path).convert("RGBA")
    if img.size != REQ_SIZE:
        img = img.resize(REQ_SIZE, Image.LANCZOS)
    return img

def split_quadrants(img):
    w, h = img.size
    hw, hh = w // 2, h // 2
    q1 = img.crop((0,     0,     hw, hh))  # top-left
    q2 = img.crop((hw,    0,     w,  hh))  # top-right
    q3 = img.crop((0,     hh,    hw, h ))  # bottom-left
    q4 = img.crop((hw,    hh,    w,  h ))  # bottom-right
    return {"q1": q1, "q2": q2, "q3": q3, "q4": q4}

def compose(q1, q2, q3, q4):
    w, h = REQ_SIZE
    hw, hh = w // 2, h // 2
    out = Image.new("RGBA", REQ_SIZE)
    out.paste(q1, (0,   0))
    out.paste(q2, (hw,  0))
    out.paste(q3, (0,  hh))
    out.paste(q4, (hw, hh))
    return out

def safe_name(s):
    return "".join(c if c.isalnum() or c in "-_." else "-" for c in s.strip().lower())

# -------------------------------------------------
# === NOVO: geração de ondulação tileável
# -------------------------------------------------
def _rng_from_names(a_name: str, b_name: str) -> np.random.RandomState:
    seed = (hash(a_name) ^ (hash(b_name) << 1)) & 0x7FFFFFFF
    return np.random.RandomState(seed)

def _periodic_curve(n: int, periods: int, amp: float, rng: np.random.RandomState) -> np.ndarray:
    """Soma de senos com períodos inteiros → valor(0) == valor(n). Tileável."""
    xs = np.linspace(0, 2*np.pi*periods, n, endpoint=False)
    # 2-3 harmônicos aleatórios para variar a costa, mantendo periodicidade
    y = np.zeros(n, dtype=np.float32)
    harmonics = [(1.0, 1.0), (2.0, 0.6), (3.0, 0.35)]
    rng.shuffle(harmonics)
    for k, w in harmonics[:3]:
        phase = rng.uniform(0, 2*np.pi)
        y += w * np.sin(k*xs + phase)
    y /= np.max(np.abs(y)) + 1e-6
    return (y * amp).astype(np.int32)

def _avg_edge_color_rgba(img: Image.Image, side: str, span: int = 12) -> tuple:
    """Cor média RGBA de uma tirinha perto da junção, usando a PRIMEIRA imagem."""
    arr = np.asarray(img)
    if side == "right":  # pegar faixa do lado direito da imagem A (junção vertical)
        cut = arr[:, -span:, :]
    elif side == "left":
        cut = arr[:, :span, :]
    elif side == "bottom":  # junção horizontal
        cut = arr[-span:, :, :]
    elif side == "top":
        cut = arr[:span, :, :]
    else:
        cut = arr
    mean = cut.reshape(-1, cut.shape[-1]).mean(axis=0)
    return tuple(int(round(v)) for v in mean)

def _paint_shoreline(out_arr: np.ndarray, mask_shore: np.ndarray, color_rgba: tuple):
    r, g, b, a = color_rgba
    out_arr[mask_shore] = np.array([r, g, b, a], dtype=np.uint8)

# -------------------------------------------------
# === NOVO: blends com prainha ondulada (tileável)
# -------------------------------------------------
def blend_wavy_lr(img_left: Image.Image, img_right: Image.Image, a_name: str, b_name: str) -> Image.Image:
    """Junção vertical ondulada (esq A, dir B) com prainha da cor média de A."""
    w, h = REQ_SIZE
    hw = w // 2

    A = np.asarray(img_left).copy()
    B = np.asarray(img_right).copy()

    rng = _rng_from_names(a_name, b_name)
    offset = _periodic_curve(h, WAVE_PERIODS, WAVE_AMP, rng)  # depende de y → casa topo/base
    shore_half = SHORE_W // 2

    out = np.empty_like(A)
    # shore_color = _avg_edge_color_rgba(img_left, side="right", span=12)
    shore_color = (0, 0, 0, 255)
    # Construção linha a linha
    for y in range(h):
        xb = hw + int(offset[y])
        xs0 = max(0, xb - shore_half)
        xs1 = min(w, xb + shore_half + (SHORE_W % 2))
        # esquerda (A)
        if xs0 > 0:
            out[y, :xs0] = A[y, :xs0]
        # direita (B)
        if xs1 < w:
            out[y, xs1:] = B[y, xs1:]
        # prainha
        out[y, xs0:xs1] = shore_color

    return Image.fromarray(out, mode="RGBA")

def blend_wavy_tb(img_top: Image.Image, img_bottom: Image.Image, a_name: str, b_name: str) -> Image.Image:
    """Junção horizontal ondulada (topo A, baixo B) com prainha da cor média de A."""
    w, h = REQ_SIZE
    hh = h // 2

    A = np.asarray(img_top).copy()
    B = np.asarray(img_bottom).copy()

    rng = _rng_from_names(a_name, b_name)
    offset = _periodic_curve(w, WAVE_PERIODS, WAVE_AMP, rng)  # depende de x → casa esquerda/direita
    shore_half = SHORE_W // 2

    out = np.empty_like(A)
    # shore_color = _avg_edge_color_rgba(img_top, side="bottom", span=12)
    shore_color = (0, 0, 0, 255)
    for x in range(w):
        yb = hh + int(offset[x])
        ys0 = max(0, yb - shore_half)
        ys1 = min(h, yb + shore_half + (SHORE_W % 2))
        # topo (A)
        if ys0 > 0:
            out[:ys0, x] = A[:ys0, x]
        # base (B)
        if ys1 < h:
            out[ys1:, x] = B[ys1:, x]
        # prainha
        out[ys0:ys1, x] = shore_color

    return Image.fromarray(out, mode="RGBA")

def blend_wavy_cross(img_comp, major_img, minor_img, major_name, minor_name, odd_label):

    w, h = REQ_SIZE
    hw, hh = w // 2, h // 2
    out = np.asarray(img_comp).copy()

    # Cores de praia vindas do major (faixas internas perto do centro)
    # shore_v_color = _avg_edge_color_rgba(major_img, side="right", span=12)
    # shore_h_color = _avg_edge_color_rgba(major_img, side="bottom", span=12)
    shore_v_color = (0, 0, 0, 255)
    shore_h_color = (0, 0, 0, 255)

    rng_v = _rng_from_names(major_name, minor_name)
    rng_h = _rng_from_names(minor_name, major_name)  # troca ordem p/ variar um pouco
    off_v = _periodic_curve(h, WAVE_PERIODS, WAVE_AMP, rng_v)  # vertical: função de y
    off_h = _periodic_curve(w, WAVE_PERIODS, WAVE_AMP, rng_h)  # horizontal: função de x
    shore_half = SHORE_W // 2

    # --- VERTICAL (meia altura somente do lado do quadrante ímpar)
    PAD = max(4, SHORE_W // 2)  # largura dos "recheios" colados à faixa

    # --- VERTICAL (só metade que encosta no quadrante ímpar)
    y_start, y_end = (0, hh) if odd_label in ("topleft","topright") else (hh, h)
    odd_is_left = odd_label in ("topleft","bottomleft")

    # fontes alinhadas (mesmo tamanho/coords):
    MA = np.asarray(major_img)   # major em todo o canvas
    MI = np.asarray(minor_img)   # minor em todo o canvas (usaremos só junto à curva)

    for y in range(y_start, y_end):
        xb = hw + int(off_v[y])
        xs0 = max(0, xb - shore_half)
        xs1 = min(w, xb + shore_half + (SHORE_W % 2))

        # banda esquerda colada à faixa (garante cor 100% do lado esquerdo da curva)
        xl0 = max(0, xs0 - PAD); xl1 = xs0
        if xl1 > xl0:
            if odd_is_left:
                out[y, xl0:xl1] = MI[y, xl0:xl1]   # lado do quadrante ímpar → MINOR
            else:
                out[y, xl0:xl1] = MA[y, xl0:xl1]   # lado oposto → MAJOR

        # faixa de prainha
        out[y, xs0:xs1] = shore_v_color

        # banda direita colada à faixa
        xr0 = xs1; xr1 = min(w, xs1 + PAD)
        if xr1 > xr0:
            if odd_is_left:
                out[y, xr0:xr1] = MA[y, xr0:xr1]   # lado direito → MAJOR
            else:
                out[y, xr0:xr1] = MI[y, xr0:xr1]   # lado direito é o ímpar → MINOR

    # --- HORIZONTAL (só metade que encosta no quadrante ímpar)
    x_start, x_end = (0, hw) if odd_label in ("topleft","bottomleft") else (hw, w)
    odd_is_top = odd_label in ("topleft","topright")

    for x in range(x_start, x_end):
        yb = hh + int(off_h[x])
        ys0 = max(0, yb - shore_half)
        ys1 = min(h, yb + shore_half + (SHORE_W % 2))

        # banda superior colada à faixa
        yt0 = max(0, ys0 - PAD); yt1 = ys0
        if yt1 > yt0:
            if odd_is_top:
                out[yt0:yt1, x] = MI[yt0:yt1, x]   # acima da curva → MINOR
            else:
                out[yt0:yt1, x] = MA[yt0:yt1, x]   # acima → MAJOR

        # faixa de prainha
        out[ys0:ys1, x] = shore_h_color

        # banda inferior colada à faixa
        yb0 = ys1; yb1 = min(h, ys1 + PAD)
        if yb1 > yb0:
            if odd_is_top:
                out[yb0:yb1, x] = MA[yb0:yb1, x]   # abaixo → MAJOR
            else:
                out[yb0:yb1, x] = MI[yb0:yb1, x]   # abaixo é o ímpar → MINOR

        # ----- CAP ARREDONDADO NA QUINA -----
    # Ponto de interseção das duas ondas no meio
    odd_is_left = odd_label in ("topleft","bottomleft")
    odd_is_top  = odd_label in ("topleft","topright")

    # centro (x_c, y_c) próximo da quina verdadeira
    x_c = hw + int(off_v[hh - 1 if odd_is_top else hh])
    y_c = hh + int(off_h[hw - 1 if odd_is_left else hw])

    R  = CORNER_RADIUS
    th = SHORE_W  # espessura do traço; acompanha sua faixa preta

    # recorte para não varrer a imagem inteira
    x0 = max(0, x_c - (R + th))
    x1 = min(w, x_c + (R + th))
    y0 = max(0, y_c - (R + th))
    y1 = min(h, y_c + (R + th))

    if x1 > x0 and y1 > y0:
        # grids locais
        yy, xx = np.ogrid[y0:y1, x0:x1]
        dist = np.sqrt((xx - x_c)**2 + (yy - y_c)**2)

        # qual “lado” do círculo pertence ao quadrante ímpar
        # (define o setor da pizza que é do MINOR)
        if   odd_is_top  and odd_is_left:
            inside_sector = (xx <= x_c) & (yy <= y_c)   # topo-esquerda
        elif odd_is_top  and not odd_is_left:
            inside_sector = (xx >= x_c) & (yy <= y_c)   # topo-direita
        elif (not odd_is_top) and odd_is_left:
            inside_sector = (xx <= x_c) & (yy >= y_c)   # baixo-esquerda
        else:
            inside_sector = (xx >= x_c) & (yy >= y_c)   # baixo-direita

        # anel (traço) preto
        ring = (dist >= R - th//2) & (dist <= R + th//2)
        out[y0:y1, x0:x1][ring] = (0, 0, 0, 255)

        # “recheios” dos dois lados do anel (mantém cor correta por lado)
        inner = dist < (R - th//2)   # lado de dentro do anel
        outer = dist > (R + th//2)   # lado de fora do anel

        # MINOR do lado do quadrante ímpar; MAJOR do outro lado
        out[y0:y1, x0:x1][inner & inside_sector] = MI[y0:y1, x0:x1][inner & inside_sector]
        out[y0:y1, x0:x1][outer & inside_sector] = MA[y0:y1, x0:x1][outer & inside_sector]

    return Image.fromarray(out, mode="RGBA")

# -------------------------------------------------
# Pipeline principal (com as 12 saídas)
# -------------------------------------------------
def generate():
    img_a_path = entry_img_a.get().strip()
    img_b_path = entry_img_b.get().strip()
    name_a = safe_name(entry_name_a.get() or "imgA")
    name_b = safe_name(entry_name_b.get() or "imgB")
    out_dir = entry_out.get().strip()

    if not os.path.isfile(img_a_path) or not os.path.isfile(img_b_path):
        messagebox.showerror("Erro", "Selecione os arquivos de imagem A e B.")
        return
    if not out_dir:
        messagebox.showerror("Erro", "Selecione a pasta de saída.")
        return
    os.makedirs(out_dir, exist_ok=True)

    try:
        img_a = load_image(img_a_path)
        img_b = load_image(img_b_path)
    except Exception as e:
        messagebox.showerror("Erro ao abrir imagem", str(e))
        return

    qa = split_quadrants(img_a)
    qb = split_quadrants(img_b)

    outputs = []

    # 1) left-A-right-B  (com prainha da cor de A)
    out = blend_wavy_lr(img_a, img_b, name_a, name_b)
    fname = f"left-{name_a}-right-{name_b}.png"
    outputs.append((out, fname))

    # 2) left-B-right-A
    out = blend_wavy_lr(img_b, img_a, name_b, name_a)
    fname = f"left-{name_b}-right-{name_a}.png"
    outputs.append((out, fname))

    # 3) top-A-bottom-B
    out = blend_wavy_tb(img_a, img_b, name_a, name_b)
    fname = f"top-{name_a}-bottom-{name_b}.png"
    outputs.append((out, fname))

    # 4) top-B-bottom-A
    out = blend_wavy_tb(img_b, img_a, name_b, name_a)
    fname = f"top-{name_b}-bottom-{name_a}.png"
    outputs.append((out, fname))

    label_to_q = {"topleft": "q1", "topright": "q2", "bottomleft": "q3", "bottomright": "q4"}

    def build_threeparts(major_name, minor_name, q_major, q_minor, odd_label):
        parts = {
            "q1": q_major["q1"],
            "q2": q_major["q2"],
            "q3": q_major["q3"],
            "q4": q_major["q4"],
        }
        odd_q = label_to_q[odd_label]
        parts[odd_q] = q_minor[odd_q]

        base = compose(parts["q1"], parts["q2"], parts["q3"], parts["q4"])

        # === NOVO: aplica prainha ondulada nas duas linhas centrais
        major_img = img_a if major_name == safe_name(entry_name_a.get() or "imgA") else img_b
        minor_img = img_a if major_name != safe_name(entry_name_a.get() or "imgA") else img_b
        out_img = blend_wavy_cross(base, major_img, minor_img, major_name, minor_name, odd_label)

        fname = f"threeparts-{major_name}-{odd_label}-{minor_name}.png"
        return out_img, fname

    # 5-8) threeparts-A-oddpos-B
    for oddpos in ["topleft", "topright", "bottomleft", "bottomright"]:
        outputs.append(build_threeparts(name_a, name_b, qa, qb, oddpos))

    # 9-12) threeparts-B-oddpos-A
    for oddpos in ["topleft", "topright", "bottomleft", "bottomright"]:
        outputs.append(build_threeparts(name_b, name_a, qb, qa, oddpos))

    # Salvar
    saved = []
    for img, fname in outputs:
        out_img = img
        if downscale_var.get():
            out_img = img.resize(OUT_SMALL, Image.LANCZOS)
            out_path = os.path.join(out_dir, f"100x100-{fname}")
        else:
            out_path = os.path.join(out_dir, fname)
        out_img.save(out_path, format="PNG")
        saved.append(out_path)

    messagebox.showinfo("Pronto!", f"{len(saved)} imagens geradas em:\n{out_dir}")

# -------------------------------------------------
# UI
# -------------------------------------------------
root = tk.Tk()
root.title(APP_TITLE)
root.resizable(False, False)

pad = 6
frm = tk.Frame(root)
frm.pack(padx=10, pady=10)
downscale_var = tk.BooleanVar(value=False)

# Imagem A
tk.Label(frm, text="Imagem A:").grid(row=0, column=0, sticky="w", padx=pad, pady=pad)
entry_img_a = tk.Entry(frm, width=55)
entry_img_a.grid(row=0, column=1, padx=pad, pady=pad)
tk.Button(frm, text="Escolher...", command=lambda: browse_img(entry_img_a)).grid(row=0, column=2, padx=pad, pady=pad)

tk.Label(frm, text="Nome A (ex.: terra):").grid(row=1, column=0, sticky="w", padx=pad, pady=pad)
entry_name_a = tk.Entry(frm, width=20)
entry_name_a.grid(row=1, column=1, sticky="w", padx=pad, pady=pad)

# Imagem B
tk.Label(frm, text="Imagem B:").grid(row=2, column=0, sticky="w", padx=pad, pady=pad)
entry_img_b = tk.Entry(frm, width=55)
entry_img_b.grid(row=2, column=1, padx=pad, pady=pad)
tk.Button(frm, text="Escolher...", command=lambda: browse_img(entry_img_b)).grid(row=2, column=2, padx=pad, pady=pad)

tk.Label(frm, text="Nome B (ex.: agua):").grid(row=3, column=0, sticky="w", padx=pad, pady=pad)
entry_name_b = tk.Entry(frm, width=20)
entry_name_b.grid(row=3, column=1, sticky="w", padx=pad, pady=pad)

# Saída
tk.Label(frm, text="Pasta de saída:").grid(row=4, column=0, sticky="w", padx=pad, pady=pad)
entry_out = tk.Entry(frm, width=55)
entry_out.grid(row=4, column=1, padx=pad, pady=pad)
tk.Button(frm, text="Escolher...", command=lambda: browse_out()).grid(row=4, column=2, padx=pad, pady=pad)

# Botão principal
btn = tk.Button(frm, text="Gerar 12 imagens", width=20, command=generate)
btn.grid(row=5, column=0, columnspan=3, pady=(pad*2, pad))

# Checkbox para reduzir as saídas para 100x100
chk = tk.Checkbutton(frm, text="Gerar em 100×100 (downscale na hora de salvar)", variable=downscale_var)
chk.grid(row=6, column=0, columnspan=3, sticky="w")

# Dica
hint = tk.Label(
    frm, fg="#555",
    text=(
        "Agora com borda ondulada tileável ('prainha') usando a cor da imagem A nas junções.\n"
        "Padrões: left/right, top/bottom e threeparts (4 + 4)."
    )
)
hint.grid(row=7, column=0, columnspan=3, sticky="w", padx=pad, pady=(0, pad))

def browse_img(entry):
    path = filedialog.askopenfilename(
        title="Selecione uma imagem 1024x1024",
        filetypes=[("Imagens", "*.png;*.jpg;*.jpeg;*.webp;*.bmp")]
    )
    if path:
        entry.delete(0, tk.END)
        entry.insert(0, path)

def browse_out():
    path = filedialog.askdirectory(title="Selecione a pasta de saída")
    if path:
        entry_out.delete(0, tk.END)
        entry_out.insert(0, path)

root.mainloop()
